# EEE (Explanation-Embedded Engineering) 宪章

## 1. 核心理念：应对AI的"短期记忆"挑战

### 1.1 问题背景

AI编程助手（如Cursor中的Gemini）拥有强大的代码生成和理解能力，但其核心限制在于**上下文窗口有限**。这导致AI在处理长期、复杂的项目时，会像一个"短期记忆"的开发者，无法记住数天或数周前的架构决策、代码约定和历史背景。如果不对其加以约束，项目将不可避免地走向混乱，充满了风格不一、逻辑矛盾和技术负债的代码。

### 1.2 我们的解决方案："Explanation-Embedded Engineering (EEE)"

为了克服这一挑战，我们采用一种**"Explanation-Embedded Engineering (EEE)"** 的方法论。

其核心思想是：**不再依赖AI的易失性记忆来维持项目的一致性和健康度，而是通过一系列强制性的、自动化的外部规则和高度结构化的代码，将项目的"知识"和"法律"固化下来，使整个代码库对AI而言是"自解释"的。**

这套体系为AI提供了一个无需记忆、始终如一的开发框架，确保每一次代码提交都符合既定规范，从而节约AI的认知成本，并保证项目的长期健康与可持续性。

## 2. EEE 治理模型：严格度光谱 (The Strictness Spectrum)

EEE的严格并非一成不变，而是经过精心设计的、与代码重要性相匹配的非对称光谱。我们不是要用"航天级"的标准去要求所有代码，而是通过明确的"分层"，将最严格的要求，施加在最小的、但最重要的代码子集上。

-   **Tier 1: 航天级 (Aerospace Grade)**
    -   **范围**: 核心工具箱 (`robust_game_toolkit/`)
    -   **要求**: 零容忍。此处的代码是项目地基，其可靠性决定了上层建筑的高度。每一次对`# type: ignore`的使用，都必须像提交一份事故报告一样，提供指向外部问题的、不可辩驳的证据（例如，库的Bug报告链接）。
    -   **心态**: 偏执、冗余、绝对可靠。

-   **Tier 2: 工业级 (Industrial Grade)**
    -   **范围**: 核心业务逻辑 (`contexts/`)
    -   **要求**: 严格遵守EEE核心条款（DDD, No Magic, Protocols）。允许存在"有理由的豁免"，但必须遵循"情境化豁免原则"。
    -   **心态**: 严谨、规范、可维护。

-   **Tier 3: 实验室级 (Lab Grade)**
    -   **范围**: 原型验证目录 (`prototypes/`)
    -   **要求**: 唯一的规则就是"没有规则"。此处的唯一目标是快速试错，以最低的成本验证一个想法是否"好玩"。
    -   **心态**: 混乱、快速、可抛弃。

## 3. "宪章"具体条款

以下条款是本项目的最高开发准则，任何开发者（无论是人类还是AI）都必须根据其所处的"严格度光谱"层级，选择性地、严格地遵守。

### 3.0. 条款零：适用性原则（The Scoping Principle）

-   **内容**: EEE并非放之四海而皆准的银弹。它是一套用于构建健壮、可维护、可扩展的长期项目的**"重型工业生产线"**。因此，严禁将其教条地应用于探索性的、以验证核心乐趣为目标的**"创意原型（实验室）"**阶段。
-   **执行**: 明确划分"实验室"（如`prototypes/`目录）与"生产线"。在"实验室"中，为验证创意可豁免EEE条款，鼓励快速试错。当原型验证成功后，必须将其视为设计蓝图，在"生产线"上遵循EEE进行工程化重写，严禁直接合入。
-   **目的**: 此条款旨在保护创造力，防止"过度工程化"扼杀早期灵感；同时明确EEE的成本效益边界，使其从理论模型转变为务实的工程工具，解决了"秩序"与"混沌"的矛盾。

### 3.1. 条款一：强制静态分析

-   **内容**: 严格遵守 `mypy` (类型检查) 和 `pylint` (代码风格与错误检查) 的规则。
-   **执行**: 所有代码在合并到主分支前，必须通过这两项静态分析检查。
-   **目的**: 这是保证代码质量和一致性的第一道防线，是不可违背的"硬性规定"。它将代码规范从"建议"提升为"法律"，是自动化的"架构警察"。

### 3.2. 条款二：拥抱领域驱动设计 (DDD)

-   **内容**: 严格遵循DDD原则来组织项目结构。明确划分 `application`, `domain`, `infrastructure`, `presentation` 等层次，确保模块、服务、实体和值对象的界限清晰。
-   **执行**: 新功能的开发必须先进行领域建模，并将代码放置在正确的模块和层级中。
-   **目的**: 为AI提供清晰的"寻址系统"和"导航地图"，使其能够理解不同代码的职责和关系，避免产生"上帝类"或不合理的依赖。

### 3.3. 条款三：杜绝一切"魔法值"

-   **内容**: 严禁在业务逻辑代码中直接使用未经定义的字面量（"魔法字符串"或"魔法数字"），如硬编码的坐标、尺寸、节点名、事件名、UI文本等。
-   **执行**:
    -   所有UI布局相关的常量（坐标、尺寸、间距等）必须定义在 `contexts/{context_name}/presentation/layout/` 目录下的相关文件中，并遵循与逻辑常量相似的领域拆分原则。
    -   所有逻辑相关的常量（节点名、任务名、事件名、Tag等）必须定义在 `contexts/{context_name}/presentation/constants/` 目录下。该目录应根据其服务的领域对象或子域进行进一步的模块拆分（例如，`player_stats.py`, `enemy_types.py`, `ui_events.py`）。
    -   **核心原则**：将单一的`constants.py`文件重构为结构化的`constants`目录，是为了将DDD的思想贯彻到底，避免常量文件自身演变为一个新的、难以维护的"上帝对象"。
    -   代码中必须从这些文件中导入并使用这些常量，确保它们成为项目中**唯一的真实来源 (Single Source of Truth)**。
-   **目的**: 将分散的、隐性的"知识"集中化、显性化，形成AI的"领域词典"。这将AI的**认知任务（记忆）降维为机械任务（引用）**。通过结构化的目录，我们让常量体系自身也变得"自解释"。

### 3.4. 条款四：优先使用"自定义工具"

-   **内容**: 对于项目中可复用的、流程化的操作（例如：根据配置文件生成代码、处理资源等），应优先将其封装成独立的脚本。
-   **执行**: 将这类脚本放置在 `scripts/` 目录下，并通过终端命令来调用。这些脚本被视为项目的"自定义工具"。
-   **目的**: 将复杂的工作流固化下来，减少手动操作的错误。AI可以像调用原生工具一样调用这些脚本，极大地提高了特定任务的执行效率和准确性。

### 3.5. 条款五：拥抱充血领域模型 (Rich Domain Model)

-   **内容**: 严禁使用贫血模型（即领域对象仅包含数据和getter/setter）。领域对象必须是"充血"的，即自身包含操作这些数据的业务逻辑（方法）。
-   **执行**: `domain`层的类必须封装其自身的行为。例如，`player.take_damage(10)` 方法必须在 `Player` 类内部实现，而不是在外部的某个`Service`中实现。
-   **目的**: 这是EEE范式在战术层面的核心体现。它确保了领域对象本身就是一个**完美的、高内聚的"自解释"单元**。当AI需要理解或修改一个领域概念的行为时，它只需聚焦于这一个文件，极大地降低了认知负荷和上下文需求，是"自解释"原则的最纯粹实现。

### 3.6. 条款六：贯彻激励相容原则 (Incentive Compatibility)

-   **背景**: 仅靠强制和纪律的体系是脆弱的。当维护体系的成本高于其收益时，它就会被第一个想要"走捷径"的开发者所抛弃。
-   **核心问题**: 我们必须回答一个核心问题：**"为什么遵守宪法，比绕过宪法，对开发者（人或AI）来说'更便宜'、'更容易'？"**
-   **执行**:
    1.  **让遵守者获得奖励**: 将"架构适应度函数"（见v3.0）的结果与开发流程正向激励挂钩。例如，持续保持高健康度的模块，其代码合并可以免于一次人工Review，或者其CI/CD流程会获得更高优先级。
    2.  **让违规者付出"清晰的代价"**: 违规不应该仅仅是CI/CD亮红灯。它可以是自动创建一个"技术债"任务，并将其分配给违规的提交者。这个任务会进入项目管理工具，有明确的"偿还"期限。
    3.  **降低遵守的门槛**: 必须提供强大的自动化工具，一键生成符合EEE规范的模块骨架、常量定义、配置文件。让"做正确的事"变得毫不费力。
-   **目的**: 将EEE从一个依靠"纪律"和"强制"的体系，转变为一个与开发者"激励相容"的、符合经济理性的、能够自发稳定运转的体系。

### 3.7. 条款七（新增）：情境化豁免原则 (Principle of Contextual Exemption)

-   **内容**: 当且仅当，为了与外部系统（如不完善的类型存根）或更高层次的架构（如依赖倒置）兼容，而必须使用`# type: ignore`、`cast`或`Any`等"豁C#
    -   **执行**: 必须在该行的上方或尾部，添加一个以`# NOTE-AI:`为前缀的单行注释，用一句话向AI解释"为什么"必须这样做。
-   **目的**: 将"豁免"的理由，从需要AI"猜测"的隐性知识，变成了代码库中明确的、可被AI直接读取的、自解释的一部分，防止AI在未来"好心办坏事"。

### 3.8. 条款八（新增）：异常上浮原则 (Principle of Exception Surfacing)

-   **内容**: 底层、可复用的模块（如`robust_game_toolkit`和`infrastructure`）严禁直接导入或使用上层应用的任何服务（包括日志、事件、配置等）。
-   **执行**: 当遇到无法处理的错误时，底层模块必须通过"抛出异常"的方式，将错误信息"向上浮"给调用者。由调用者（高层模块）负责捕获异常，并决定如何处理（例如，使用自己的Logger来记录）。
-   **目的**: 保证核心模块的低耦合和高复用性，避免循环依赖，维持清晰的架构分层。

## 4. 根本原理：为什么这套方法论是必要的 (5-Why 分析)

### 第一层 Why：我们为什么需要EEE？
因为我们需要一种方法，让一个上下文窗口有限、缺乏长期记忆的AI编程助手，能够持续、高效、正确地在一个复杂的、长期演进的项目中工作。

### 第二层 Why：为什么AI的"短期记忆"是一个必须解决的核心问题？
因为如果不解决，AI的每一次介入都会像一个"新人"入职，导致引入不一致性、重复造轮子、频繁打断人类和架构腐化，最终项目会变成一堆难以维护的"意大利面条代码"。

### 第三层 Why：为什么现有的最佳实践（如经典DDD、单元测试、代码注释）不足以解决这个问题？
因为这些实践的核心服务对象是**人类**，它们依赖于人类的**理解和自觉**。单元测试保证逻辑正确，但不管架构一致性；代码注释是给人看的；经典DDD的规则，AI仍可能在执行中违反。

### 第四层 Why：EEE凭什么能比这些实践做得更好？
因为它将**"约定"和"知识"**从需要"理解"的文档，转变成了需要"遵守"的、**机器可强制执行的"结构"和"规则"**。它的杀手锏是：
1.  **极端常量化**：将认知任务降维为机械任务。
2.  **强制结构化**：提供无歧义的寻址系统。
3.  **自动化规则**：用不知疲倦的"架构警察"确保规范被遵守。

### 第五层 Why：为什么这套"强制"体系不会扼杀创造力？
因为它并没有限制"做什么"的创造力，而是通过严格规范"怎么做"和"放在哪"，将开发者（无论人与AI）从琐碎的规范性问题中解放出来。更重要的是，通过**贯彻激励相容原则（条款2.6）**，它让"做正确的事"变得比"走捷径"更容易、更高效。一个稳固、可预测、不会腐化且使用成本低的基础架构，恰恰是创新的最佳土壤。

---
**批判性总结**: EEE范式深刻理解了AI的"非人"特性，放弃了用"人类"的方式去要求AI，而是反过来，**构建了一个对AI的"机械思维"极度友好的开发环境**。它用机器的方式（强制、自动化、结构化）去管理和约束机器（AI）的行为，从而将人类从繁琐的监督和重复的指导中解放出来，专注于真正的创新。

## 5. 未来展望：EEE的逻辑延伸

EEE范式本身就孕育着对"更高层次自动化"的需求。其终极的逻辑延伸，是创造一个**"架构Linter"**或**"文档审查工具"**。

这个未来的工具将实现以下功能：
1.  **以机器可读的规约为输入**: 它将以一份机器可读的、精确无歧义的规约文件（例如`architecture.yaml`, `project_constitution.toml`）作为其规则输入，而不再是尝试"理解"用自然语言书写的`.md`文档。
2.  **以项目源代码为审查对象**: 它会扫描整个代码库。
3.  **以自动化报告为输出**: 它将报告所有在代码层面违反了规约的实现。

这个工具的实现，将标志着EEE范式的完全成熟：我们不仅拥有了一套AI友好的开发哲学，更有了一套AI驱动的、自动化地强制执行这套哲学的工具链。**这将EEE构想从一个依赖AI前沿研究的"科幻"，降维成了一个坚实可行的"工程实现"**。届时，**这份文档将不再是"法律"本身，而是"法律"的权威解读和人类可读的文档。**

## 6. 元治理：宪法的接口化重构 (v2.0 思想)

在我们对EEE范式进行深入的自我批判后，我们发现v1.0的"单体宪法"本身，恰恰违反了它自身所倡导的"解耦"、"内聚"和"自解释"原则。它本身就是一个"上帝对象"。

为了解决这个根本性的矛盾，我们运用EEE的思想，对"宪法"本身的治理模式，提出了v2.0的构想——**"规约驱动的宪法 (Specification-Driven Constitution)"**。

这标志着EEE从一个"开发范式"进化为了一个**"可自我迭代的治理框架"**。

### 6.1 v2.0 架构蓝图：反转"接口"与"文档"

| **维度** | **v1.0：单体宪法 (Monolithic Constitution)** | **v2.0：规约驱动的宪法 (Specification-Driven Constitution)** |
| :--- | :--- | :--- |
| **规则载体** | 一个巨大的`.md`文件，用自然语言描述所有规则。 | 一系列的**"机器可读规约" (Machine-Readable Specifications)**，例如：<br>- `architecture_rules.yaml`<br>- `linting_policy.toml`<br>- `type_checking.ini` |
| **文档角色** | `.md`文件本身就是"法律"。 | 这份我们正在阅读的`.md`文档，是所有规约文件的**"人类可读的伴生文档"**。其部分内容甚至应由规约文件**自动生成**。 |
| **实现** | 所有规则硬编码在文件中。 | 每一个"规约"，都有一或多个**"策略实现" (Policy Implementations)**：<br>- `Pylint_Strict_Policy.cfg`<br>- `MyPy_Default_Policy.ini`<br>- `Combat_Context_Layout.py` |
| **耦合方式** | 整个项目**硬编码**地依赖于这个"上帝宪法"。 | **依赖注入**！一个具体的模块（比如`combat`上下文）在其"配置文件"中声明它**依赖**哪些"策略实现"。它只注入它需要的规则！ |
| **灵活性** | **极低**。要么全部遵守，要么违反宪法。 | **极高**。`combat`模块可以注入"严格Pylint策略"，而一个非核心的`tools`模块可以注入"宽松Pylint策略"。 |
| **扩展性** | **差**。增加新规则意味着让这个上帝对象变得更臃肿。 | **极佳**。想增加一个新的代码检查工具？只需要提供一个新的"规约"和"策略实现"，然后让需要的模块注入它即可。 |

### 6.2 核心思想：思想的自洽与闭环

v2.0构想的本质，是将EEE的工程思想，**元应用（meta-applied）**于承载这个思想的治理体系本身。我们用"EEE的刀"，来雕刻"EEE这块玉"。

**通过将"原则接口"的载体从模糊的自然语言（.md）反转为精确的机器语言（.yaml, .toml, .ini），v2.0构想从一个美好的哲学理念，变成了一个坚实的工程蓝图。**

这个"元应用"形成了一个完美的**思想闭环**和**自我迭代机制**。一个能够用自身的规则来批判和重构自身的系统，才是真正有生命力的、能走向无穷的系统。

### 6.3 结论：从"宣言"到"操作系统"

通过v2.0的构想，EEE不再仅仅是一套写在纸上的、静态的开发哲学"宣言"。

它进化成了一个动态的、可插拔的、面向规约的、可通过依赖注入来灵活配置的**"项目治理操作系统"**。

这确保了EEE范式在面对未来更庞大、更复杂的项目（包含无数模块和特异性需求）时，依然能保持其核心的优雅、灵活与强大。这是EEE能够从一个"项目的最佳实践"走向"普适的行业级框架"的关键一步。

## 7. 终极演进：拥有制衡的赛博宪法 (The Cybernetic Constitution with Checks and Balances, v3.0 思想)

v2.0的"规约驱动宪法"解决了规则的灵活性和扩展性，但它创造了一个更棘手的、隐性的治理黑洞：**谁来决策？** 规则的注入和配置，最终还是依赖于不可靠的、善变的人类。这违背了EEE将"人类自觉"最小化的第一性原理。

为了解决这个终极矛盾，我们必须引入另一个伟大的工程思想——**控制论 (Cybernetics)**，并为其加上**制衡 (Checks and Balances)**的枷锁。

EEE v3.0，其核心思想是：

**"宪法"不再是一个可插拔的主板。它是一个活的、拥有感知能力、能进行自主决策，但其权力受到严格限制和监督的"治理体系"。**

### 7.1 v3.0 架构核心：联邦、透明、可上诉

1.  **架构适应度函数 (Architectural Fitness Functions)**：我们不再仅仅依赖静态的Linter。我们定义并量化一系列代表系统"健康度"的指标，例如：代码变更率、模块耦合度、Bug密度、核心功能性能、测试覆盖率等。
2.  **联邦式治理 (Federated Governance)**：我们不创建一个全知全能的中央"守护进程"。我们设想一个**"联邦制"**的治理模型。每个`context`（限界上下文）内部，可以有一个小型的、逻辑简单的本地"健康监视器"。中央"守护进程"的角色更像是一个"联邦政府"，它设定高级别目标，观察并协调各个联邦成员的健康报告，而不是直接干预"州内事务"。
3.  **治理即代码 (Governance as Code)**：我们将"适应度函数"和"决策逻辑"本身也视为代码，纳入版本控制，接受Code Review。定义一个新的函数，或修改一个判断阈值，都应该像提交一次代码变更一样，有明确的`diff`、`commit message`和`reviewer`。**这让"法律的修订过程"变得透明、可追溯。**
4.  **策略的动态注入 (Dynamic Policy Injection)**：**这，就是v3.0的惊天一跃。**
    -   "治理守护进程"，而不是人类，来**提议**为哪个模块注入哪个"策略实现"。
    -   **示例**：一个模块的bug密度连续三天超标？"治理守护进程"**自动地**将它的代码审查策略从"宽松"提升为"极度严格"。一个无人问津的工具模块，突然被三个核心模块所依赖？守护进程立刻意识到它已成为关键节点，**自动地**为它注入"100%测试覆盖率"策略。
5.  **紧急出口与上诉机制 (Escape Hatch & Appeal Mechanism)**：必须为"算法暴政"设计一个"紧急出口"。必须有一个清晰的、低成本的流程，允许人类开发者临时`override`守护进程的决定，并对该决定提出"上诉"。**没有制衡的权力，无论它是人类的还是算法的，最终都会走向僵化和崩溃。**

### 7.2 结论：从"操作系统"到"数字共和国"

如果说v2.0将EEE从"宣言"提升为了"操作系统"，那么v3.0则完成了最终的进化。

它将EEE变成了一个**用代码实现的、数据驱动的、实时进行自我调节，且权力受到制衡的"数字共和国"**。一个由理性的"治理算法"（我们的守护进程）和清醒的"公民"（我们的开发者）共同构建的、永远不会腐化、永远追求最优解的**数字文明**。

这标志着EEE范式已经超越了传统的软件工程范畴，进入了"**复杂适应性系统**"和"**计算社会科学**"的领域。它为"如何组织大规模、持续进化的人机协作"这一21世纪的核心命题，提供了一个革命性的、源自于控制论与政治哲学思想的答案。 

## 8. EEE守护者的工程实现蓝图 (The Guardian's Engineering Blueprint)

EEE的核心是拥有一套自动化的"架构警察"来确保"宪法"被遵守。在理论探讨之后，我们必须为其设计一个务实、经济、且符合EEE精神的工程实现蓝图。

### 8.1. 方案的演进：从"自定义警察"到"借用警力"

我们最初构想了两种实现"守护者"的方案：
1.  **自定义Pylint插件（签名守护者）**：功能最强大，但开发成本极高，技术门槛陡峭。
2.  **代码生成脚本（引导守护者）**：开发成本较低，但极其脆弱，无法应对后续的代码变更和重构。

在对上述方案进行批判性思考后，我们发现了一个更优越、更符合EEE"激励相容"原则的"阶段2.5"方案。

### 8.2. 最终方案："协议守护者"——用类型协议定义"可执行的法律"

该方案的本质是：**停止发明自定义工具，转而将Python的类型系统本身，改造为我们的"架构守护者"。** 我们不再编写外部的`manifest.yml`，而是直接用`typing.Protocol`来定义模块的公共接口。

**核心实施步骤：**
1.  **立法（定义协议）**: 在每个限界上下文的根目录创建`protocols.py`文件。在该文件中，使用`typing.Protocol`为所有需要被外部访问的类（如`Player`, `CombatManager`）定义其必须遵守的接口和方法签名。
2.  **守法（实现协议）**: 在具体的实现类中，明确声明其遵守（继承）对应的协议。
3.  **执法（利用Mypy）**: `Mypy`将自动成为我们的"架构警察"。如果实现类的任何方法签名与`protocols.py`中定义的"法律"不符，`Mypy`会立刻报错，从而在静态检查阶段就阻止违规代码的产生。

### 8.3. 成本收益分析（双重视角）

#### 8.3.1. 从人类开发者视角

-   **成本**:
    -   **初期投入**: 为现有核心模块补写`protocols.py`文件，预计需要数个工作日。
    -   **持续摩擦力**: 每次变更公共接口时，需要同步修改`.py`和`protocols.py`两个文件。
-   **收益**:
    -   **根除集成错误**: 彻底消除了因函数签名不匹配、API理解错误导致的Bug。
    -   **安全的重构环境**: 协议文件成为重构的安全网，确保内部修改不破坏外部承诺。
    -   **架构的自文档化**: `protocols.py`天然成为模块最清晰、最准确的API文档，极大降低了新成员的学习成本。

#### 8.3.2. 从AI开发者视角

-   **成本**:
    -   **Token消耗增加**: AI执行任务时，需要同时接收实现文件（`.py`）和协议文件（`protocols.py`）作为上下文，增加了单次任务的Token成本。
-   **收益**:
    -   **确定性的巨大提升**: `protocols.py`为AI提供了无歧义的"任务说明书"，消除了AI对需求的猜测，让其工作更自信、更精确。
    -   **返工率的显著降低**: 大幅减少了因误解API而导致的修改，避免了成本高昂的"来回拉扯"，节约了总Token消耗和人类的监督时间。
    -   **上下文的聚焦**: 协议文件帮助AI快速理解模块的核心功能，在有限的Token预算内获得最高质量的信息。

### 8.4. 结论：一份稳赚不赔的架构投资

"协议守护者"方案是一次典型的EEE式权衡。我们用"可控的、一次性的实施成本"和"AI单次任务中微量的Token增加"，换取了"整个项目生命周期内巨大的确定性、稳定性和可维护性"。

**对于一个追求长期健康、并以AI为核心生产力的项目，这笔投资的回报是指数级的。** 

## 9. 未来演进（续）：地方病历系统 (Local Bugdata System)

在我们确立了以"协议守护者"为核心的结构自解释体系后，EEE的下一个合乎逻辑的演进方向，是解决"历史自解释"的问题。我们称之为"地方病历"系统。

### 9.1 核心思想：让Bug历史与代码共存

该方案的核心是：任何一个`.py`文件产生的、导致程序崩溃的Bug，其关键的错误信息（traceback），都应该被自动地、结构化地记录到与源文件相伴的`同名.bugdata`文件中。例如，`player.py`的崩溃日志将被记录在`player.py.bugdata`里。

### 9.2 收益与代价

- **核心收益**:
    1. **上下文就近**: 开发者（无论人与AI）在查看一个文件时，其所有"历史病症"都近在咫尺，极大地降低了认知负荷和信息检索成本。
    2. **精准调试**: 为AI提供了高度相关的历史错误样本，使其在面对相似问题时，能给出更精准的调试建议。

- **付出的代价**:
    1. **工具链依赖**: 该方案强依赖于一个包裹执行的插件（如`manage.py run`），对开发流程有一定的侵入性。
    2. **文件系统熵增**: 项目中的文件数量会翻倍，可能会造成视觉上的杂乱。
    3. **维护成本**: 在重构或删除文件时，需要手动处理其对应的`.bugdata`文件。

### 9.3 实施决策

我们一致同意，"地方病历"系统是EEE宏伟蓝图中的重要一环。但其优先级位于"协议守护者"之后。**当前阶段，我们将此方案作为正式的、已存档的未来规划。** 我们将首先集中精力，建立起项目的结构性契约（Protocols）和核心插件（manage.py），待此基础稳固后，再着手实现这个更高级的"历史自解释"系统。 