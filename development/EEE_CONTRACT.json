{
  "contract_version": "1.2.0",
  "metadata": {
    "name": "EEE (嵌入式自解释工程) 核心原则",
    "description": "定义EEE框架自身的、基础性的、机器可读的契约。本契约旨在赋能AI驱动的软件工程实践的自动化分析、引导与演进。",
    "status": "实验室探索阶段",
    "status_description": "在此阶段，并非所有原则都强制要求完全自动化，允许手动干预和工具链的迭代开发。"
  },
  "ethical_mandates": {
    "name": "伦理守护契约",
    "enforcement": "absolute",
    "description": "此部分定义了系统必须强制执行的伦理与安全护栏。这些规则拥有最高优先级，且不能被其他配置覆盖。",
    "rules": []
  },
  "principles": [
    {
      "id": 1,
      "name": "结构化契约",
      "core_statement": "所有核心业务对象、数据结构与函数接口，都必须通过强类型协议进行显式定义，禁止使用泛型字典或列表来承载核心业务逻辑。",
      "keywords": ["type safety", "interface", "protocol", "schema"],
      "implementation_guidance": "使用Pydantic、TypedDict或Dataclasses等语言特性或库来强制执行。",
      "verification_tools": ["mypy"]
    },
    {
      "id": 2,
      "name": "语义化锚点",
      "core_statement": "严禁使用无法自我解释的魔术值（如字符串、数字）。所有此类常量都必须在一个中心化的、领域特定的常量模块中定义并导入使用。",
      "keywords": ["magic values", "constants", "centralization"],
      "implementation_guidance": "创建专用的模块（如 user_constants.py）来存储和导出字面量值。",
      "verification_tools": ["linter", "custom_grep_scanner"]
    },
    {
      "id": 3,
      "name": "实时反馈",
      "core_statement": "任何代码的生成或修改，都必须能立即、自动地通过一个预定义的自动化质量门禁。",
      "keywords": ["quality gate", "feedback loop", "automation"],
      "implementation_guidance": "将Pytest、Ruff和Mypy等工具集成到AI代理的文件保存或代码提交动作中。",
      "verification_tools": ["pytest", "ruff", "mypy"]
    },
    {
      "id": 4,
      "name": "知识破局",
      "core_statement": "在同一个技术问题上连续三次尝试失败后，必须暂停当前方法，并触发网络搜索以获取新的解决方案或外部知识。",
      "keywords": ["retry limit", "deadlock", "web search"],
      "implementation_guidance": "为任务实现一个重试计数器。当达到限制时，调用网络搜索工具。",
      "verification_tools": ["web_search_api", "task_runner_logs"]
    },
    {
      "id": 5,
      "name": "情境化记忆",
      "core_statement": "在修改任何文件前，系统必须检查是否存在一个对应的错误历史文件（如 .py.bugset），并将其内容作为高优先级上下文，以避免重复犯错。",
      "keywords": ["bug history", "contextualization", "scar tissue"],
      "implementation_guidance": "在修改前的工作流中集成文件系统检查。将bugset文件的内容送入AI的上下文中。",
      "verification_tools": ["filesystem_watcher", "RAG_indexer"]
    },
    {
      "id": 6,
      "name": "动态蓝图",
      "core_statement": "所有工作都必须由一个结构化的、机器可读的任务文档（如 TASK.json）来驱动，该文档代表了系统当前的使命和状态。",
      "keywords": ["task management", "state machine", "mission-driven"],
      "implementation_guidance": "使用JSON或YAML文件来定义任务、依赖和状态。AI的主循环应该读取并更新此文件。",
      "verification_tools": ["task_parser", "state_validator"]
    },
    {
      "id": 7,
      "name": "动态自解释架构契约",
      "core_statement": "项目的架构风格与设计模式，必须通过一个中心化的、版本化的、机器可读的架构契约（如 design_contract.json）进行定义，以实现低成本、高可靠的自动化架构重构。",
      "keywords": ["architecture contract", "refactoring", "self-explanation", "ADL"],
      "implementation_guidance": "这是元原则。为您的项目创建design_contract.json文件，并构建工具链（扫描器、规划器、执行器）来强制执行它。",
      "verification_tools": ["EEEScanner", "RefactorPlanner", "RefactorExecutor"]
    },
    {
      "id": 8,
      "name": "分层意图契约",
      "core_statement": "AI不能直接听自然语言干活。它必须先把和人类的对话，生成一份对人类友好的对话草案，待人类确认后，再编译成一份对机器友好的执行合同。",
      "keywords": ["intent contract", "communication", "verification"],
      "implementation_guidance": "使用Gherkin/Markdown格式生成对话草案，使用JSON格式生成执行合同。",
      "verification_tools": ["gherkin_parser", "json_validator"]
    },
    {
      "id": 9,
      "name": "任务委派与成本优化",
      "core_statement": "AI在执行任务前，必须评估是否可以将任务或子任务委派给更高效的专门工具。",
      "keywords": ["cost optimization", "task delegation", "efficiency"],
      "implementation_guidance": "建立工具评估机制，维护工具性能和成本数据库。",
      "verification_tools": ["cost_analyzer", "tool_selector"]
    }
  ],
  "glossary": {
    "Pydantic": "一个基于Python类型提示，进行数据校验和设置管理的库。是实现原则1的关键工具。",
    "Mypy": "Python的静态类型检查器。是原则1的主要验证工具。",
    "DDD": "领域驱动设计 (Domain-Driven Design)，一种专注于构建丰富领域模型的架构方法。是原则7首个成功实践的风格。",
    "RAG": "检索增强生成 (Retrieval-Augmented Generation)，一种为语言模型提供外部知识的技术。是实现原则5的关键技术之一。"
  }
} 